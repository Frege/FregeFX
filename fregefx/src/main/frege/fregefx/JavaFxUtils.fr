module fregefx.JavaFxUtils where

import frege.Prelude hiding(ListView)


import fregefx.JavaFxType
import fregefx.JavaFxAll
import Control.Concurrent

--- The starter for every FregeFX Application
data FregeFX = mutable native org.frege.FregeFX where
    native launch  org.frege.FregeFX.launch :: ( Stage -> JFX () ) -> IO ()
    native fxml    org.frege.FregeFX.fxml   :: String -> String -> JFX Parent

--- Run any function _f_ in the JavaFX Application Thread to ensure proper painting.
--- Any code that touches a JavaFX UI component must run in this thread.
withUI :: JFX () -> JFX ()
withUI f = Platform.runLater =<< Runnable.new f

--- Given a _populate_ logic on how to build a scenegraph below the root group
--- and a _stage_, assemble the pieces and show the stage.
withStage :: (Group -> Stage -> JFX Group) -> Stage -> JFX ()
withStage populate stage = do
    content <- Group.new ()
    scene   <- Scene.new content
    stage.setScene scene
    populate content stage
    stage.show

--- JavaFX users will work with ObservableList a lot, which inherits from List.
--- The mutable java.util.List type is usually not visible in Frege but when
--- using JavaFX, having these methods accessible is convenient.
data List e = mutable native java.util.List where
  native add  :: List e -> e -> JFX Bool
  native size :: List e -> JFX Int
  native remove :: List e -> e -> JFX Bool

-- todo dk: remove duplication below

--- Generic implementation of the ChangeListener Interface in Java to use from Frege
data OnChange t = mutable native org.frege.FregeChangeListener where
    native new :: (t -> t -> JFX () ) -> JFX (OnChange t)

--- Generic implementation of the EventHandler Interface in Java to use from Frege
data OnEvent t = mutable native org.frege.FregeEventHandler where
    native new  :: (t -> JFX () ) -> JFX (OnEvent t)

--- Generic implementation of the ChangeListener Interface in Java to use from Frege
data OnChangeIO t = mutable native org.frege.FregeChangeListener where
    native new :: (t -> t -> IO () ) -> JFX (OnChangeIO t)

--- Generic implementation of the EventHandler Interface in Java to use from Frege
data OnEventIO t = mutable native org.frege.FregeEventHandler where
    native new  :: (t -> IO () ) -> JFX (OnEventIO t)

data Bridge t = mutable native org.frege.FregeIoJfxBridge where
    native new :: (()->IO t) -> (t -> JFX ()) -> JFX (Bridge t)
    native bridge :: Bridge t -> JFX ()

bridgeAction :: ButtonBase -> (()->IO t) -> (t -> JFX ()) -> JFX ButtonBase
bridgeAction button ioAction jfxAction = do
    newBridge <- Bridge.new ioAction jfxAction
    handler <- OnEvent.new (\_ -> newBridge.bridge )
    button.setOnAction handler
    return button


--- Convenience function to set an action event handler as
--- > action button $ \event -> button.setText "got it"
action :: ButtonBase -> (ActionEvent -> JFX () ) -> JFX ButtonBase
action button eventHandler = do
    handler <- OnEvent.new eventHandler
    button.setOnAction handler
    return button

actionIO :: ButtonBase -> (ActionEvent -> IO () ) -> JFX ButtonBase
actionIO button eventHandler = do
    handler <- OnEventIO.new eventHandler
    button.setOnAction handler
    return button

--- Convenience function to set an action event handler
--- that does not depend on the action event as
--- > action_ button (button.setText "got it")
action_ :: ButtonBase -> JFX () -> JFX ButtonBase
action_ button plainHandler = action button (const plainHandler)

actionIO_ :: ButtonBase -> IO () -> JFX ButtonBase
actionIO_ button plainHandler = actionIO button (const plainHandler)

--- Convenience factory function for insets
insets :: Double -> JFX Insets
insets n = Insets.new n n n n

--- A Family type is a type that has _children_ and can attain more of them over time
class Family family where
    children :: family -> JFX (ObservableList Node)

instance Family Group where
    children group = group.getChildren

instance Family HBox where
    children hbox = hbox.getChildren

instance Family VBox where
    children hbox = hbox.getChildren


--- Convenience function to add a control/pane/node to a family
add :: Family t => t -> JFX Region -> JFX t
add family builder = do
    child <- builder
    family.children >>= _.add child
    return family

infixr 3 `<:`
(<:) = add

--- Convenience function that applies _add_ to all entries in the list.
addAll :: Family family => family -> [JFX Region] -> JFX family
addAll family builders = do
    mapM (add family) builders
    return family




{--
    Unsafe, best-effort function for looking up a node in a scene.
    This returns a Node value on the Java side but in order to do
    anything sensible with this on the Frege side, we need a specialized subtype like @TextArea@.
    The function lookupNode returns such a specialized type by returning an instance of @IO CastTarget@.
    Errors are thrown at runtime if the selector String cannot be found or yields the wrong type.
    *Use only if you are ok with runtime errors!*
-}
lookupNode :: CastTarget a => Scene -> String -> JFX a
lookupNode scene selector = do
    mayNode <- scene.lookup selector
    case mayNode of
        Just node -> downcast node >>= either
            (\cce -> error $ "cannot cast selector '" ++ selector ++ "'. Reason: " ++ show cce.getMessage)
            return
        Nothing   -> error $ "cannot find '" ++ selector ++ "'"


data ClassCastException = native java.lang.ClassCastException

-- generalized downcast
class CastTarget a where
    downcast :: Node -> JFX (ClassCastException | a)

instance CastTarget TextArea where
    native downcast "(javafx.scene.control.TextArea)" :: Node -> JFX (ClassCastException | TextArea    )

instance CastTarget (ListView t) where
    native downcast "(javafx.scene.control.ListView)" :: Node -> JFX (ClassCastException | ListView t  )
